uniform_float cfg_intensity {
    default = 3.5;
    min = 0.0;
    max = 20.0;
    step = 0.1;
    display_name = "Intensity";
    description = "Determines the strength of the effect.";
}

uniform_float cfg_radius {
    default = 35.0;
    min = 2.0;
    max = 100.0;
    step = 1.0;
    display_name = "Radius";
    description = "Controls the radius of occlusion effects.";
}

uniform_float cfg_depth_compensation {
    default = 25.0;
    min = 0.0;
    max = 50.0;
    step = 1.0;
    display_name = "Depth Compensation";
    description = "The extent to which occlusion is regulated by the relative depth to the occluder.";
}

uniform_int cfg_samples {
    default = 30;
    min = 5;
    max = 100;
    step = 1;
    display_name = "Samples";
    description = "The number of samples taken to determine occlusion. More samples means better quality occlusion, but worse performance.";
}

uniform_bool cfg_debug {
    default = false;
    display_name = "Debug";
    description = "Makes it easier to see the effect of occlusion by removing other lighting effects.";
}

fragment ssao {
    omw_In vec2 omw_TexCoord;

    vec3 norm_at(vec2 uv) {
        return vec3(omw_Texture2D(omw_SamplerNormals, uv).xyz - 0.5) * 2.0;
    }

    void main() {
        vec4 old_col = omw_Texture2D(omw_SamplerLastShader, omw_TexCoord);
        if (OMW_NORMALS != 1) {
            omw_FragColor = old_col * vec4(1.0, 0.0, 0.0, 1.0);
            return;
        }

        float depth = omw_GetLinearDepth(omw_TexCoord);
        float inv_depth = 1.0 / depth;
        float dist_mul = cfg_radius / sqrt(depth + 0.001);
        vec3 norm = norm_at(omw_TexCoord);

        float ssao = 0.0;
        float total = 0.0;
        float t = dot(sin(omw_TexCoord * 10000.0), vec2(1.0));
        for (int i = 0; i < cfg_samples; i ++) {
            float dist = 0.1 + fract(t * 0.79) * dist_mul;
            vec2 offs = sin(vec2(0.0, 1.571) + t) * 0.01 * dist;
            vec2 pos = omw_TexCoord + offs;

            float depth2 = omw_GetLinearDepth(pos);
            float weight = 1.0 / (dist + abs(1.0 - depth2 * inv_depth) * cfg_depth_compensation);
            vec3 norm2 = norm_at(pos);
            ssao += 0.01 / (0.01 + max(dot(norm.xy - norm2.xy, offs), 0.0)) * weight;
            total += weight;
            t += 2.9;
        }

        if (cfg_debug) {
            old_col.rgb = vec3(1.0);
        }

        vec3 col = old_col.rgb * pow(min(ssao / total, 1.0), cfg_intensity);

        omw_FragColor = vec4(col.rgb, 1.0);
    }
}

technique {
    passes = ssao;
    version = "0.1";
    description = "Screen-space ambient occlusion for OpenMW";
    author = "zesterer";
    pass_normals = true;
}
