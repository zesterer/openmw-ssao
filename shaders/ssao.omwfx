uniform_bool cfg_enabled {
    default = true;
    display_name = "Enabled";
    description = "Whether the effect is enabled (useful for quick comparisons). If you want to permanently remove the effect, disable the whole shader instead of using this option.";
}

uniform_float cfg_intensity {
    default = 5.0;
    min = 0.0;
    max = 20.0;
    step = 0.1;
    display_name = "Intensity";
    description = "Determines the strength of the effect.";
}

uniform_float cfg_radius {
    default = 30.0;
    min = 2.0;
    max = 200.0;
    step = 1.0;
    display_name = "Radius";
    description = "Controls the radius of occlusion effects.";
}

uniform_float cfg_depth_compensation {
    default = 0.1;
    min = 0.0001;
    max = 0.5;
    step = 0.01;
    display_name = "Depth Compensation";
    description = "The extent to which occlusion is regulated by the relative depth to the occluder.";
}

uniform_int cfg_samples {
    default = 20;
    min = 5;
    max = 100;
    step = 1;
    display_name = "Samples";
    description = "The number of samples taken to determine occlusion. More samples means better quality occlusion, but worse performance.";
}

uniform_bool cfg_debug {
    default = false;
    display_name = "Debug";
    description = "Makes it easier to see the effect of occlusion by removing other lighting effects.";
}

sampler_2d noise {
    source = "textures/noise.png";
    mag_filter = nearest;
    min_filter = nearest;
    wrap_s = repeat;
    wrap_t = repeat;
    source_format = red;
    internal_format = red;
    source_type = unsigned_byte;
}

shared {
    /* const int N = 7; */
    /* const float kernel[N] = float[](0.0016,    0.0372,    0.2394,    0.4436,    0.2394,    0.0372,    0.0016); */
    /* const float taps[N] = float[](-3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0); */

    const int N = 7;
    const float kernel[N] = float[](0.0713,	0.1315,	0.1899,	0.2146,	0.1899,	0.1315,	0.0713);
    const float taps[N] = float[](-3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0);

    /* const int N = 5; */
    /* const float kernel[N] = float[](0.0013, 0.1573, 0.6827, 0.1573, 0.0013); */
    /* const float taps[N] = float[](-2.0, -1.0, 0.0, 1.0, 2.0); */

    /* const int N = 9; */
    /* const float kernel[N] = float[](0.0002, 0.0060, 0.0606, 0.2417, 0.3829, 0.2417, 0.0606, 0.0060, 0.0002); */
    /* const float taps[N] = float[](-4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0); */

    vec2 rcpResolution = 1.0 / omw.resolution * 1.15;

    vec3 norm_at(vec2 uv) {
        return (omw_Texture2D(omw_SamplerNormals, uv).xyz - 0.5) * 2.0;
    }
}

fragment ssao {
    omw_In vec2 omw_TexCoord;

    #define HORIZON 100000000
    vec2 norm2_at(vec2 uv) {
        return vec2(omw_Texture2D(omw_SamplerNormals, uv).xy - 0.5) * 2.0;
    }

    float hash_two(uvec2 q) {
        #define M1 2047667443U
        #define M2 3883706873U

        q *= uvec2(M1, M2);
        uint n = q.x ^ q.y;
        n = n * (n ^ (n >> 15));
        return float(n) * (1.0 / float(0xffffffffU));
    }

    void main() {
        float depth = omw_GetLinearDepth(omw_TexCoord);
        float inv_depth = 1.0 / depth;
        float dist_mul = cfg_radius / (10.0 + sqrt(depth) * 0.15);
        vec2 norm = norm2_at(omw_TexCoord);
        float depth_comp = 1.0 / cfg_depth_compensation;

        vec3 wpos = omw_GetWorldPosFromUV(omw_TexCoord);

        float ssao = 0.0;
        float total = 0.0;
        // Always apply AO in interiors, and not on the skybox
        if (!omw.isInterior && (depth > HORIZON
            // AO shouldn't appear underwater if the camera is above water
            || (wpos.z < omw.waterHeight + 10.0 && !omw.isUnderwater)
            // AO shouldn't appear above water if the camera is underwater
            || (wpos.z > omw.waterHeight - 10.0 && omw.isUnderwater)))
        {
            ssao = 1.0;
            total = 1.0;
        } else {
            float t = hash_two(uvec2(omw_TexCoord * omw.resolution));
            for (int i = 0; i < cfg_samples; i ++) {
                float dist = 0.1 + pow(fract(t * 22.8), 1) * dist_mul;
                vec2 offs = sin(vec2(0.0, 1.571) + t) * 0.01 * dist;
                vec2 pos = omw_TexCoord + offs;

                float depth2 = omw_GetLinearDepth(pos);
                vec2 norm2 = norm2_at(pos);
                float weight = 1.0 / (dist + abs(1.0 - depth2 * inv_depth) * depth_comp);
                ssao += 0.01 / (0.01 + max(dot((norm - norm2), offs), 0.0)) * weight;
                total += weight;
                t += 2.4;
            }
        }

        omw_FragColor = vec4(vec3(ssao / total), 1.0);
    }
}

fragment blur_v {
    omw_In vec2 omw_TexCoord;

    void main()
    {
        float ssao = 0.0;
        for(int i = 0; i < N; i ++)
            ssao += omw_GetLastPass(omw_TexCoord + vec2(0, rcpResolution.y * taps[i])).x * kernel[i];

        omw_FragColor = vec4(vec3(ssao), 1.0);
    }
}

fragment blur_h {
    omw_In vec2 omw_TexCoord;

    void main()
    {
        float ssao = 0.0;
        for(int i = 0; i < N; i ++)
            ssao += omw_GetLastPass(omw_TexCoord + vec2(rcpResolution.x * taps[i], 0)).x * kernel[i];

        omw_FragColor = vec4(vec3(ssao), 1.0);
    }
}

fragment combine {
    omw_In vec2 omw_TexCoord;

    void main()
    {
        vec4 old_col;
        if (cfg_debug) {
            old_col.rgb = vec3(1.0);
        } else {
            old_col = omw_GetLastShader(omw_TexCoord);
            if (OMW_NORMALS != 1) {
                omw_FragColor = old_col * vec4(1.0, 0.0, 0.0, 1.0);
                return;
            }
        }

        float ssao = 0.0;
        for(int i = 0; i < N; i ++)
            ssao += omw_GetLastPass(omw_TexCoord + vec2(rcpResolution.x * taps[i], 0)).x * kernel[i];

        if (!cfg_enabled) {
            ssao = 1.0;
        }

        old_col.rgb *= mix(smoothstep(0.0, 1.0, pow(min(ssao, 1.0), cfg_intensity)), 1.0, omw_EstimateFogCoverageFromUV(omw_TexCoord));

        /* old_col.rgb = norm_at(omw_TexCoord); */

        omw_FragColor = old_col;
    }
}

technique {
    passes = ssao, blur_v, combine;
    version = "0.1";
    description = "Screen-space ambient occlusion for OpenMW";
    author = "zesterer";
    pass_normals = true;
}
